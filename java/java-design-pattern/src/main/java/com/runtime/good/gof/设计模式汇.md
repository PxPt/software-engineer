---
1.七原则
---
- 里式替换原则
    > 子类尽量不要重写父类的方法,尽可能的使用 (依赖,聚合,组合实现)
- 单一接口原则
    > 一个类只有且仅有一个令其发生改变的原因
- 依赖倒置原则
    > 面向抽象编程(接口/抽象类) 
- 接口隔离原则
    > 子类实现不应该依赖不需要的接口
- 迪米特法则原则
    > 类对于自己知道的越少越好 (直接朋友: 传参/返回值/成员变量 | 间接朋友: 直接New/...)
- 合成复合原则
    > 优先使用组合或者聚合关系复用,少用继承关系复用
- 左闭右开原则
    > 对扩展开放,对修改关闭       
---
口令:
一个替换了里式的女人,
牵着一头有职责的羊,
把羊的接口隔离后,
使它的依赖倒置,
跟他的朋友迪米特法则商量,
复用合成技术打包,
卖给了左闭右开原则.
**********************************************
### 2.创建型模式
#### 单例模式
​	1. 略
#### 工厂模式
1. 抽象工厂（Abstract Factory）提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
2. 具体工厂（ConcreteFactory）主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
3. 抽象产品（Product）定义了产品的规范，描述了产品的主要特性和功能。
4. 具体产品（ConcreteProduct）实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。
--- 三种模式 : 普通 / 工厂模式 / 抽象工厂模式

#### 建造者模式

1. 产品角色（Product）它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。
2. 抽象建造者（Builder）它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。
3. 具体建造者(Concrete Builder）实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
4. 指挥者（Director）它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。
   - 将复杂对象的创建过程抽象出来,使这个抽象过程的不同实现可以构建出不同的对象.

#### 原型模式
1. 抽象原型类：规定了具体原型对象必须实现的接口。
2. 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。
3. 访问类：使用具体原型类中的 clone() 方法来复制新的对象。
   
    - 浅拷贝 : 如果是基本数据类型,浅拷贝会进行值传递,将该属性值复制一份给新的对象,如果是引用数据类型,浅拷贝会进行地址值引用传递. (当修改时成员变量时,会影响另一个对象的该成员变量值)
    - 深拷贝 : 为所有的数据类型的成员变量申请存储空间,并复制每个引用数据类型成员变量所引用对象,直到该对象可达的所有对象.

#### Structural model
#### 代理模式

1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。

3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

- **静态代理**
  - **优点**: 在不修改目标对象的前体下,通过代理对象对目标功能增强
  - **缺点**: 代理类与真实主题类都需要实现抽象接口,所以会有很多代理类.(一旦抽象主题增加方法,真实主题与代理类都需要维护)

- **动态代理**
  - 代理类不需要实现接口,但真实主题类需要实现接口,否则不能使用动态代理 |  **代理对象的生成** 利用JDK的API,动态的在内存中构建代理对象
- **Cglib代理**
  - 子类代理,在内存中构建一个子类对象从而实现对目标对象实现功能扩展.使用Cglib代理时,不需要实现任何接口
  - 底层是通过使用字节码处理框架ASM来转换字节码生成新的类
- 如何选择代理模式
  1. 目标对象需要实现接口,就用JDK代理
  2. 目标对象不需要实现接口,就用Cglib 代理

#### 适配器模式

1. 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
2. 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
3. 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。
   - 类适配器模式 | 接口适配器模式 | 对象适配器模式

- **将原本不兼容的接口融合在一起**

#### 桥接模式

1. **抽象化**（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
2. **扩展抽象化**（Refined  Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
3. **实现化**（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
4. **具体实现化**（Concrete Implementor）角色：给出实现化角色接口的具体实现。

- **1.** 抽象与实现分离,让抽象部分与实体部分独立开来 | **2.**桥接模式需要识别出系统中两个独立的维度

- 使用场景
  - 不希望使用继承或多层继承导致系统类的个数急速增加的系统
    - JDBC 驱动程序
    - 银行转账系统 **转账分类**:网上转账/柜台转账 /AMT转账 |  **转账类型**: 普通用户/银卡用户/金卡用户
    - 消息管理 **消息类型**:即时消息,延时消息 | **消息分类**: 手机短信,邮件消息,QQ消息

#### 装饰模式

1. 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
2. 具体构件（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。
3. 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
4. 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

- 不改变现有对象结构的情况下，动态地给该对象增加一些职责 (即增加其额外功能);
- 采用装饰模式扩展对象的功能比采用继承方式更加灵活 |可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。
  - 例如JDK中的 io流 InputStream


       